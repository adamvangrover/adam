import axios from 'axios';

// Types for better safety
export interface SystemStatus {
  status: 'ONLINE' | 'OFFLINE' | 'SIMULATED';
  latency: number;
  version: string;
}

export interface DataManifest {
  reports: Array<{ id: string; title: string; date: string; type: string; path: string }>;
  agents: Array<{ id: string; name: string; status: string; specialization: string }>;
}

const API_BASE_URL = 'http://localhost:5001/api';

class DataManager {
  private useFallback: boolean = false;
  private connectionChecked: boolean = false;
  private manifestCache: DataManifest | null = null;
  private simulationInterval: NodeJS.Timeout | null = null;
  private marketDataCache: any = {
    SPY: 512.45,
    BTC: 68500.00,
    ETH: 3500.00,
    VIX: 14.20
  };

  constructor() {
    // Start background simulation for dynamic values
    this.startSimulationEngine();
  }

  private startSimulationEngine() {
    if (this.simulationInterval) return;
    this.simulationInterval = setInterval(() => {
      // Update market data slightly
      this.marketDataCache.SPY += (Math.random() * 0.5 - 0.25);
      this.marketDataCache.BTC += (Math.random() * 50 - 25);
      this.marketDataCache.ETH += (Math.random() * 10 - 5);
      this.marketDataCache.VIX += (Math.random() * 0.2 - 0.1);

      // Keep VIX positive
      if (this.marketDataCache.VIX < 10) this.marketDataCache.VIX = 10;
    }, 2000);
  }

  async checkConnection(): Promise<SystemStatus> {
    try {
      const start = Date.now();
      await axios.get(`${API_BASE_URL}/health`, { timeout: 2000 });
      this.useFallback = false;
      return { status: 'ONLINE', latency: Date.now() - start, version: 'v23.5' };
    } catch (error) {
      this.useFallback = true;
      return { status: 'SIMULATED', latency: 0, version: 'v23.5 (Offline)' };
    } finally {
      this.connectionChecked = true;
    }
  }

  // Phase 2: Manifest Crawler Simulation
  async getManifest(): Promise<DataManifest> {
    // Try to fetch generated manifest from public folder first
    try {
        // Fetch ui_manifest.json (generated by script) instead of PWA manifest
        const response = await axios.get('/ui_manifest.json');
        if (response.data && (response.data.reports || response.data.agents)) {
            this.manifestCache = response.data;
            return response.data;
        }
    } catch (e) {
        console.warn('UI Manifest not found, using internal mock.');
    }

    if (this.useFallback || !this.manifestCache) {
      // Simulate crawling core/libraries_and_archives
      this.manifestCache = {
        reports: [
          { id: 'NVDA_2025', title: 'NVDA Deep Dive', date: '2025-02-26', type: 'JSON', path: '/data/nvda.json' },
          { id: 'MM_OCT', title: 'Market Mayhem: October', date: '2025-10-31', type: 'Markdown', path: '/newsletters/mm_oct.md' },
          { id: 'CREDIT_AAPL', title: 'Apple Credit Assessment', date: '2025-03-03', type: 'SNC', path: '/reports/aapl_snc.json' },
          { id: 'ARCH_V22', title: 'v22 Architecture Review', date: '2024-12-15', type: 'Markdown', path: '/docs/arch_v22.md' }
        ],
        agents: [
          { id: 'risk_arch', name: 'Risk Architect', status: 'Active', specialization: 'Systemic Risk' },
          { id: 'market_sent', name: 'Sentiment Engine', status: 'Idle', specialization: 'NLP Analysis' },
          { id: 'quant_core', name: 'Quantum Forecaster', status: 'Processing', specialization: 'Predictive Modeling' },
          { id: 'red_team', name: 'Red Team', status: 'Standby', specialization: 'Adversarial Testing' }
        ]
      };
    }
    return this.manifestCache as DataManifest;
  }

  async getData(endpoint: string): Promise<any> {
    if (!this.connectionChecked) {
        await this.checkConnection();
    }

    if (this.useFallback) {
      return this.simulateEndpoint(endpoint);
    }

    try {
      const response = await axios.get(`${API_BASE_URL}${endpoint}`);
      return response.data;
    } catch (error) {
      console.warn(`Live fetch failed for ${endpoint}, switching to simulation.`);
      this.useFallback = true;
      return this.simulateEndpoint(endpoint);
    }
  }

  // Phase 2: Simulation Engine
  private simulateEndpoint(endpoint: string): any {
    if (endpoint.includes('market')) {
      return { ...this.marketDataCache };
    }
    if (endpoint.includes('system/health')) {
      return {
          cpu: 45 + Math.random() * 10,
          memory: 60 + Math.random() * 5,
          active_threads: 12,
          network_in: 1024 + Math.random() * 500,
          network_out: 2048 + Math.random() * 1000
      };
    }
    if (endpoint.includes('agents')) {
        return this.manifestCache?.agents || [];
    }
    return { message: "Simulated Response" };
  }

  isOfflineMode() { return this.useFallback; }

  toggleSimulationMode(enable: boolean) {
      this.useFallback = enable;
  }
}

export const dataManager = new DataManager();

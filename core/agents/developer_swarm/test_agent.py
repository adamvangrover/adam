#test_agent.py
"""
This module defines the TestAgent, a specialized agent responsible for
writing and running tests for a given piece of code.
"""

from typing import Any, Dict
from core.agents.agent_base import AgentBase

class TestAgent(AgentBase):
    """
    The TestAgent writes unit tests for code generated by the CoderAgent
    and runs them to ensure correctness.
    """

    def __init__(self, config: Dict[str, Any], **kwargs):
        super().__init__(config, **kwargs)
        self.name = "TestAgent"

    async def execute(self, code_artifact: Dict[str, str]) -> Dict[str, Any]:
        """
        Takes a code artifact and writes/runs tests for it.

        :param code_artifact: A dictionary containing the 'file_path' and 'code'.
        :return: A dictionary containing the test results.
        """
        source_code = code_artifact.get("code")
        file_path = code_artifact.get("file_path")

        # 1. Determine the path for the test file (simplified assumption)
        test_file_path = file_path.replace("core/", "tests/test_").replace(".py", "_generated_test.py")

        # 2. Construct a prompt to generate a unit test
        prompt = f"""
        You are an expert Python developer specializing in testing with pytest.
        Your task is to write a comprehensive unit test for the following code.

        **File to Test:** {file_path}
        
        **Code to Test:**
        ```python
        {source_code}
        ```

        Please provide only the Python code for the test file. The test should be self-contained.
        """

        # 3. Call the LLM to generate the test code
        # generated_test_code = await self.run_semantic_kernel_skill("test_generation", "generate_pytest_code", {"prompt": prompt})
        generated_test_code = f"""
# Placeholder test code generated by TestAgent for {file_path}
import pytest

# In a real scenario, the test would need to import the code to be tested.
# from {file_path.replace('/', '.').replace('.py', '')} import new_function

def test_placeholder_function():
    \"\"\"This is a placeholder test.\"\"\"
    assert True, "This test should be replaced with a real one."
"""
        
        # 4. Simulate writing the test file and running the tests
        # In a real implementation, this would use file I/O and subprocess tools.
        # self.tools.write_file(test_file_path, generated_test_code)
        # test_run_result = self.tools.run_command(f"pytest {test_file_path}")
        
        test_run_result = {
            "status": "success",
            "message": f"All tests in {test_file_path} passed.",
            "output": "1 passed in 0.01s"
        }

        return test_run_result

    def get_skill_schema(self) -> Dict[str, Any]:
        """
        Defines the skills of the TestAgent.
        """
        schema = super().get_skill_schema()
        schema["skills"].append(
            {
                "name": "write_and_run_tests",
                "description": "Writes and runs unit tests for a given code artifact.",
                "parameters": [
                    {"name": "code_artifact", "type": "dict", "description": "A dictionary containing the file_path and code to test."}
                ]
            }
        )
        return schema

"""
Extracts Explainable AI (XAI) reasoning traces from Adam project log files.

Purpose:
This script parses debug log messages generated by agents within the Adam project,
specifically those prefixed for XAI data capture (e.g., "SNC_XAI:", "FAA_XAI:"). 
It converts these logs into a structured JSON format, representing a trace of 
the agent's execution flow, including inputs to methods, outputs, Semantic Kernel 
skill interactions, and rule-based decisions.

The primary focus of the initial version is on logs from `snc_analyst_agent.py`.

Basic Usage:
  python scripts/extract_xai_reasoning.py --log_file /path/to/agent_run.log --output_file /path/to/trace.json

If --output_file is omitted, the JSON output is printed to stdout.

XAI Log Prefixes:
The script looks for log messages starting with specific prefixes defined in the
XAI_LOG_PATTERNS list (e.g., "SNC_ANALYSIS_EXECUTE_INPUT:", "SNC_XAI:SK_INPUT:", 
"SNC_RATING_RULE_TRIGGERED:", etc.).
"""
import argparse
import ast
import json
import logging
import re
from typing import Any, Dict, List

# Configure basic logging for the script itself (e.g., for errors during script execution)
# This is separate from the agent logs being parsed.
script_logger = logging.getLogger(__name__) # Use the script's own logger
# Note: The root logger is configured in main() if this script is run directly.
# If imported, this basicConfig might not run or might conflict.
# For a script, it's often fine, or managed in main().

# Define regex patterns for SNC Analyst Agent XAI logs
# Each entry contains an 'event_type' for categorization and a 'regex' for matching.
XAI_LOG_PATTERNS = [
    # Captures the initial input to the SNCAnalystAgent's execute method.
    {'type': 'EXECUTE_INPUT', 'regex': re.compile(r"SNC_ANALYSIS_EXECUTE_INPUT: company_id='([^']*)', all_kwargs=(.*)")},

    # Captures A2A communication requests made by the agent.
    {'type': 'A2A_REQUEST', 'regex': re.compile(r"SNC_ANALYSIS_A2A_REQUEST: Requesting data from DataRetrievalAgent: (.*)")},
    
    # Captures A2A communication responses received by the agent.
    {'type': 'A2A_RESPONSE', 'regex': re.compile(r"SNC_ANALYSIS_A2A_RESPONSE: Received data package: (True|False)")},

    # Captures a summary of data extracted from the A2A response.
    {'type': 'DATA_EXTRACTION_SUMMARY', 'regex': re.compile(r"SNC_ANALYSIS_DATA_EXTRACTED: (.*)")},

    # Captures inputs to internal analysis helper methods.
    {'type': 'FIN_ANALYSIS_INPUT', 'regex': re.compile(r"SNC_FIN_ANALYSIS_INPUT: (.*)")},
    {'type': 'FIN_ANALYSIS_OUTPUT', 'regex': re.compile(r"SNC_FIN_ANALYSIS_OUTPUT: (.*)")},
    {'type': 'QUAL_ANALYSIS_INPUT', 'regex': re.compile(r"SNC_QUAL_ANALYSIS_INPUT: (.*)")},
    {'type': 'QUAL_ANALYSIS_OUTPUT', 'regex': re.compile(r"SNC_QUAL_ANALYSIS_OUTPUT: (.*)")},
    {'type': 'CREDIT_MITIGATION_INPUT', 'regex': re.compile(r"SNC_CREDIT_MITIGATION_INPUT: (.*)")},
    {'type': 'CREDIT_MITIGATION_OUTPUT', 'regex': re.compile(r"SNC_CREDIT_MITIGATION_OUTPUT: (.*)")},

    # Captures the consolidated inputs fed into the main rating determination logic.
    {'type': 'DETERMINE_RATING_INPUT', 'regex': re.compile(r"SNC_DETERMINE_RATING_INPUT: (.*)")},

    # Captures inputs passed to a Semantic Kernel skill. Group 1 is the skill name.
    {'type': 'SK_INPUT', 'regex': re.compile(r"SNC_XAI:SK_INPUT:(\w+): (.*)")}, # Adjusted to match SNC_XAI prefix
    
    # Captures outputs from a Semantic Kernel skill. Group 1 is skill name, Group 2 is assessment, Group 3 is justification, Group 4 (optional) is concerns.
    {'type': 'SK_OUTPUT', 'regex': re.compile(r"SNC_XAI:SK_OUTPUT:(\w+): Assessment='([^']*)', Justification='([^']*)'(?:, Concerns='([^']*)')?")}, # Adjusted for SNC_XAI prefix

    # Captures the triggering of a specific rule within the rating logic.
    {'type': 'RATING_RULE', 'regex': re.compile(r"SNC_XAI:RATING_RULE(?:_FALLBACK)?: (.*)")}, # Adjusted for SNC_XAI prefix and optional _FALLBACK
    
    # Captures the parameters just before the rule-based logic in _determine_rating.
    {'type': 'RATING_LOGIC_PARAMS', 'regex': re.compile(r"SNC_XAI:RATING_PARAMS_FOR_LOGIC: (.*)")}, # Adjusted for SNC_XAI prefix

    # Captures the final rating and rationale from the _determine_rating method.
    {'type': 'FINAL_RATING_DETERMINATION', 'regex': re.compile(r"SNC_DETERMINE_RATING_OUTPUT: Final Rating='([^']*)', Rationale='(.*)'")},

    # Captures the final output of the agent's execute method.
    {'type': 'EXECUTE_OUTPUT', 'regex': re.compile(r"SNC_ANALYSIS_EXECUTE_OUTPUT: Rating='([^']*)', Rationale='(.*)'")}
]

def parse_payload(payload_str: str) -> Any:
    """
    Safely parses a string payload that might represent a Python literal (dict, list, bool, etc.).
    
    Uses ast.literal_eval for safe parsing of Python data structures.
    If parsing fails (e.g., the string is not a valid Python literal),
    it returns the original string, stripped of leading/trailing whitespace.
    Special handling for 'True' and 'False' strings to convert them to booleans.

    Args:
        payload_str (str): The string payload to parse.

    Returns:
        Any: The parsed Python object (e.g., dict, list, bool) or the stripped string if parsing fails.
    """
    try:
        # Handle common boolean string representations explicitly.
        if payload_str.lower() == 'true':
            return True
        if payload_str.lower() == 'false':
            return False
        # Attempt to parse as a Python literal.
        return ast.literal_eval(payload_str)
    except (ValueError, SyntaxError, TypeError):
        # If not a valid Python literal (e.g., a plain descriptive string), return the string.
        return payload_str.strip()

def main():
    # Configure logging for the script itself.
    # This ensures that script-specific messages (like errors) are handled,
    # separate from the agent logs being parsed.
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    parser = argparse.ArgumentParser(description="Extracts XAI reasoning traces from Adam project log files for specific agents.")
    parser.add_argument("--log_file", required=True, help="Path to the input log file.")
    parser.add_argument("--output_file", required=False, help="Optional path to the output JSON file. Prints to stdout if not provided.")
    
    args = parser.parse_args()

    trace_events: List[Dict[str, Any]] = []
    final_rating_info: Dict[str, Any] = {} # To store the overall final output of the agent

    try:
        with open(args.log_file, 'r') as f:
            for line_number, line in enumerate(f, 1):
                line = line.strip()
                
                # Regex to capture standard log parts: Timestamp - LoggerName - Level - Message
                log_line_parts_match = re.search(r"^\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2},\d{3}\s-\s([\w.]+)\s-\s(DEBUG|INFO|WARNING|ERROR|CRITICAL)\s-\s(.*)", line)
                
                if not log_line_parts_match:
                    # script_logger.debug(f"Skipping line {line_number} (does not match basic log structure): {line}")
                    continue 
                
                log_content = log_line_parts_match.group(3).strip() # The actual message content

                # Attempt to match against defined XAI log patterns
                for pattern_info in XAI_LOG_PATTERNS:
                    match = pattern_info['regex'].match(log_content) 
                    if match:
                        event_type = pattern_info['type']
                        groups = match.groups()
                        event_data: Dict[str, Any] = {'line': line_number} # Store line number for context

                        # Populate event_data based on event_type and captured groups
                        if event_type == 'EXECUTE_INPUT':
                            event_data['company_id'] = groups[0]
                            event_data['all_kwargs'] = parse_payload(groups[1])
                        elif event_type == 'A2A_REQUEST':
                            event_data['request_details'] = parse_payload(groups[0])
                        elif event_type == 'A2A_RESPONSE':
                            event_data['received_package'] = parse_payload(groups[0])
                        elif event_type in ['DATA_EXTRACTION_SUMMARY', 'FIN_ANALYSIS_INPUT', 'QUAL_ANALYSIS_INPUT', 'CREDIT_MITIGATION_INPUT', 'DETERMINE_RATING_INPUT', 'RATING_RULE', 'RATING_LOGIC_PARAMS']:
                            event_data['details'] = groups[0] 
                        elif event_type in ['FIN_ANALYSIS_OUTPUT', 'QUAL_ANALYSIS_OUTPUT', 'CREDIT_MITIGATION_OUTPUT']:
                            event_data['output_data'] = parse_payload(groups[0])
                        elif event_type == 'SK_INPUT':
                            event_data['skill_name'] = groups[0] # e.g., AssessCollateralRisk
                            event_data['input_vars'] = parse_payload(groups[1])
                        elif event_type == 'SK_OUTPUT':
                            event_data['skill_name'] = groups[0]
                            event_data['assessment'] = groups[1]
                            event_data['justification'] = groups[2]
                            if len(groups) > 3 and groups[3] is not None: 
                                event_data['concerns'] = groups[3]
                        elif event_type == 'FINAL_RATING_DETERMINATION' or event_type == 'EXECUTE_OUTPUT':
                            rating_val = groups[0]
                            rationale_val = groups[1]
                            event_data['rating'] = rating_val
                            event_data['rationale'] = rationale_val
                            if event_type == 'EXECUTE_OUTPUT': 
                                final_rating_info = {'rating': rating_val, 'rationale': rationale_val}
                        
                        # Construct the trace event dictionary
                        trace_event = {
                            'event_type': event_type,
                            'data': event_data,
                            'original_message': log_content 
                        }
                        trace_events.append(trace_event)
                        break # Processed this line, move to the next
    
    except FileNotFoundError:
        script_logger.error(f"Log file not found: {args.log_file}")
        return
    except Exception as e:
        script_logger.error(f"An error occurred during log parsing: {e}", exc_info=True)
        return

    # Prepare the final JSON output structure
    output_data = {
        "agent_execution_trace": {
            "agent_name": "snc_analyst_agent", # Hardcoded for this PoC, could be made dynamic
            "log_file": args.log_file,
            "trace_events": trace_events,
        }
    }
    if final_rating_info: # Add final output if captured
        output_data["agent_execution_trace"]["final_output"] = final_rating_info

    # Write to output file or print to stdout
    if args.output_file:
        try:
            with open(args.output_file, 'w') as outfile:
                json.dump(output_data, outfile, indent=2)
            script_logger.info(f"XAI trace successfully written to {args.output_file}")
        except IOError:
            script_logger.error(f"Could not write to output file: {args.output_file}", exc_info=True)
    else:
        print(json.dumps(output_data, indent=2))

if __name__ == '__main__':
    main()
